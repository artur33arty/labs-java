# Абубакиров Артур ФИТ-1 Лабораторная №3

# Задание 1. Инкапсуляция

## Задача 1.6: Отдельные линии

### Текст задачи
Измените сущность Линия. Необходимо, чтобы Линия соответствовала следующим требованиям:
- Две любые линии не могут ссылаться на один и тот же объект точки.
- У Линии можно изменить координаты начала или конца.
- У Линии можно запросить координаты начала или конца.

### Алгоритм решения
1.  **Конструкторы и сеттеры** класса `Line` были изменены так, чтобы они создавали **глубокие копии** передаваемых объектов `Point` (например, `this.startPoint = new Point(p.getX(), p.getY())`), а не просто присваивали ссылку.
2.  Аналогично, **геттеры** `getStartPoint()` и `getEndPoint()` возвращают новые экземпляры `Point`, а не ссылки на внутренние приватные поля класса.
3.  Такой подход гарантирует, что внутреннее состояние объекта `Line` полностью инкапсулировано. Его нельзя изменить извне через манипуляции с объектами `Point`, которые были переданы в конструктор или получены из геттеров.

## Задача 1.12: Квадрат

### Текст задачи
Создайте сущность Квадрат, которая описывается точкой левого верхнего угла и длиной стороны. Реализуйте конструкторы и проверку на корректность входных данных.

### Алгоритм решения
1.  Создан класс `Square` с приватными полями `topLeft` (типа `Point`) и `side` (типа `int`).
2.  Реализовано два перегруженных конструктора для инициализации объекта: один принимает объект `Point`, другой — координаты `x, y`.
3.  В конструкторах и в сеттере `setSide` добавлена проверка, которая выбрасывает `IllegalArgumentException`, если переданная длина стороны меньше или равна нулю. Это обеспечивает целостность и корректность состояния объекта.
4.  Переопределен метод `toString()` для вывода информации о квадрате в заданном формате.

# Задание 2. Разработка структур данных

## Задача 2.1: Неизменяемый массив

### Текст задачи
Разработать сущность `НеизменяемыйСписокЗначений`, представляющий собой обертку над массивом целых чисел, которая добавляет некоторые возможности, сохраняя неизменяемость.

### Алгоритм решения
1.  Создан `final` класс `ImmutableList`, чтобы запретить наследование и изменение его поведения.
2.  Внутренний массив `int[] values` объявлен как `final`, что делает невозможным изменение ссылки на сам массив после инициализации.
3.  Все конструкторы (`из varargs`, `из другого ImmutableList`) создают **глубокую копию** входящих данных с помощью `Arrays.copyOf()`. Это предотвращает изменение внутреннего состояния списка через внешние ссылки.
4.  Метод `set(index, value)` не изменяет текущий объект, а возвращает **новый экземпляр** `ImmutableList` с измененным значением. Это стандартный паттерн для работы с неизменяемыми (иммутабельными) объектами.
5.  Метод `toArray()` также возвращает копию внутреннего массива, а не прямую ссылку на него.

# Задание 3. Наследование

## Задача 3.5: Маршрут

### Текст задачи
Разработать сущность `Маршрут` на основе `Города`. Маршрут имеет Город начала и Город конца пути и может вернуть массив Городов, представляющий собой путь.

### Алгоритм решения
1.  Созданы вспомогательный класс `City` и основной класс `Route`.
2.  Класс `Route` содержит два поля: `startCity` и `endCity`.
3.  Конструктор `Route` проверяет, что переданные города не являются `null`, и выбрасывает `IllegalArgumentException` в противном случае.
4.  Метод `getPath()` реализован как "заглушка", которая возвращает жестко закодированный путь для демонстрации. В реальной системе здесь бы находился сложный алгоритм поиска пути по графу городов.
5.  Метод `toString()` использует `getPath()` для формирования строкового представления маршрута.

# Задание 4. Создание иерархий: abstract

## Задача 4.5: Трехмерная точка

### Текст задачи
Создайте такой подвид сущности `Точка`, который будет иметь не две, а три координаты: X, Y, Z.

### Алгоритм решения
1.  Создан новый класс `Point3D`, который **наследуется** от существующего класса `Point` с помощью ключевого слова `extends`.
2.  В `Point3D` добавлено новое приватное поле `z` для третьей координаты.
3.  Конструктор `Point3D` принимает три координаты (x, y, z) и вызывает конструктор родительского класса `Point` с помощью `super(x, y)` для инициализации унаследованных полей `x` и `y`.
4.  Метод `toString()` переопределен для вывода всех трех координат. Для доступа к `x` и `y`, которые являются `private` в родительском классе, используются публичные геттеры `getX()` и `getY()`.

# Задание 5. Полиморфизм

## Задача 5.1: Сложение

### Текст задачи
Разработайте метод, который принимает набор числовых значений и возвращает их сумму в вещественной форме. Примеры значений: `2`, `2.3`, `1/2`.

### Алгоритм решения
1.  Для представления дробей создан вспомогательный класс `Fraction`, который наследуется от абстрактного класса `java.lang.Number`. Это позволяет объектам `Fraction` участвовать в полиморфных операциях с другими числовыми типами.
2.  Класс `Fraction` реализует все абстрактные методы `Number` (`intValue`, `doubleValue` и т.д.).
3.  В утилитном классе `MathUtils` создан статический метод `sum(Number... numbers)`. Использование `Number` в качестве типа параметра позволяет методу принимать любые его подклассы (`Integer`, `Double`, `Fraction` и т.д.) благодаря полиморфизму.
4.  Внутри метода происходит итерация по всем переданным аргументам, и для каждого вызывается метод `.doubleValue()`, который возвращает значение объекта в виде `double`. Результаты суммируются.

# Задание 6. Полиморфное сравнение: equals

## Задача 6.3: Сравнение линий

### Текст задачи
Измените сущность `Линия`. Переопределите метод сравнения `equals` так, чтобы две линии считались одинаковыми, если их начало и конец расположены в одинаковых точках.

### Алгоритм решения
1.  Для корректного сравнения линий необходимо сначала реализовать `equals()` и `hashCode()` в классе `Point`, чтобы сравнивать точки по значению, а не по ссылке.
2.  В классе `Line` переопределен метод `equals(Object o)`.
3.  Логика сравнения учитывает, что линия от точки A до точки B эквивалентна линии от B до A. Проверка выглядит так: `(start1.equals(start2) && end1.equals(end2)) || (start1.equals(end2) && end1.equals(start2))`.
4.  Также переопределен метод `hashCode()`. Его реализация (`startPoint.hashCode() + endPoint.hashCode()`) не зависит от порядка точек, что соответствует контракту: если `a.equals(b)`, то `a.hashCode() == b.hashCode()`.

# Задание 7. Пакеты

### Текст задачи
1. Расположите все классы по пакетам вида `ru.surname.type`.
2. Создайте пакет `ru.surname.main` и расположите там класс с точкой входа (`main`).
3. Создайте метод для возведения в степень, принимающий две строки. Для преобразования и вычислений используйте короткие имена статических методов (`parseInt`, `pow`).

### Алгоритм решения
1.  **Задача 7.1 и 7.2** выполнены путем **организации структуры проекта**. Все классы были распределены по пакетам в соответствии с их логическим назначением: `geometry`, `collections`, `geography`, `math`. Класс `Main` с точкой входа расположен в пакете `ru.ivanov.main`.
2.  **Задача 7.3** реализована в утилитном классе `MathUtils` в методе `powerFromString(String, String)`.
3.  Для использования методов `parseInt` и `pow` без указания класса (`Integer.`, `Math.`) в файле `MathUtils.java` были использованы **статические импорты**: `import static java.lang.Integer.parseInt;` и `import static java.lang.Math.pow;`.
4.  Демонстрация работы метода показана в `Main`: через прямой вызов с тестовыми данными.

# Задание 8. Пакетная инкапсуляция и клонирование

## Задача 8.5: Клонирование линии

### Текст задачи
Измените сущность `Линия`. Переопределите метод `clone`, унаследованный от `Object`, так, чтобы он возвращал новый объект Линии, значения полей которого будут копиями полей оригинальной Линии.

### Алгоритм решения
1.  Классы `Point` и `Line` реализуют маркерный интерфейс `Cloneable`, что является обязательным условием для использования `Object.clone()`.
2.  В обоих классах переопределен метод `public Object clone()`.
3.  Клонирование в `Line` реализовано как **глубокое**. Это означает, что при вызове `clone()` для объекта `Line` создается не только его поверхностная копия, но и новые, независимые копии его полей-объектов `startPoint` и `endPoint` путем вызова их собственных методов `clone()`.
4.  Это гарантирует, что изменение клонированного объекта (или его внутренних точек) не затронет оригинал и наоборот.
