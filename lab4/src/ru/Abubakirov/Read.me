# Абубакиров Артур ФИТ-1 Лабораторная №4

# Задание 1. Обобщенные типы

## Задача 1.2: Без null

### Текст задачи
Создайте сущность Хранилище, которая может хранить один произвольный объект. Хранилище неизменяемо. Если вместо объекта хранится `null`, необходимо вернуть какое-либо альтернативное значение.

### Алгоритм решения
1.  Создан обобщенный класс `Storage<T>`, где `T` — это тип хранимого объекта.
2.  Внутреннее поле `item` объявлено как `final`, что обеспечивает неизменяемость хранилища после создания объекта.
3.  Конструктор `Storage(T item)` инициализирует это поле.
4.  Создан метод `getOrDefault(T defaultValue)`, который проверяет, равно ли внутреннее поле `item` значению `null`. Если да, возвращается `defaultValue`, в противном случае — сам `item`.

## Задача 1.5: Обобщенная линия

### Текст задачи
Измените сущность Линия таким образом, чтобы при создании её объекта можно было точно указать тип точки, на которой расположена линия (двухмерная или трехмерная). Граница стирания не может быть хуже двумерной точки.

### Алгоритм решения
1.  Класс `Line` был сделан обобщенным: `public class Line<T extends Point>`.
2.  Использование конструкции `<T extends Point>` является **ограничением сверху (upper bound)**. Это гарантирует, что в качестве типа `T` можно использовать только класс `Point` или любой из его наследников (например, `Point3D`).
3.  Внутренние поля `startPoint` и `endPoint`, а также параметры конструктора и типы возвращаемых значений геттеров были изменены с `Point` на `T`.
4.  Таким образом, можно создать экземпляр `Line<Point>` для 2D-линии или `Line<Point3D>` для 3D-линии, при этом сохранив строгую типизацию.

# Задание 2. Параметризации

## Задача 2.1: Сдвинуть линию

### Текст задачи
Создайте метод, принимающий Линию (с любой допустимой параметризацией) и сдвигающий ее точку начала на 10 единиц по оси Х.

### Алгоритм решения
1.  Создан статический метод `shiftLineStart` в утилитном классе `LineUtils`.
2.  Сигнатура метода использует **wildcard (метасимвол)**: `public static void shiftLineStart(Line<? extends Point> line)`.
3.  Конструкция `? extends Point` означает, что метод может принимать объект `Line` с *любым* неизвестным типом, который является наследником `Point`. Это делает метод универсальным для всех видов линий (`Line<Point>`, `Line<Point3D>` и т.д.).
4.  Внутри метода мы можем безопасно получить точку (`line.getStartPoint()`) и работать с ней как с объектом типа `Point`, поскольку это гарантируется ограничением `extends Point`. Метод получает ссылку на объект точки и изменяет его состояние через сеттер `setX()`.

# Задание 3. Обобщенные методы

## Задача 3.1: Функция (map)

### Текст задачи
Разработайте обобщенный метод, который принимает список значений типа `T` и объект с методом `apply`. Метод должен применить `apply` к каждому элементу списка и вернуть новый список значений типа `R`.

### Алгоритм решения
1.  Вместо создания собственного интерфейса был использован стандартный функциональный интерфейс `java.util.function.Function<T, R>`.
2.  Создан статический обобщенный метод `map` с сигнатурой `<T, R> List<R> map(List<T> list, Function<T, R> function)`.
3.  Метод создает новый пустой список `ArrayList<R>`.
4.  В цикле он проходит по каждому элементу `T` из исходного списка, применяет к нему `function.apply(item)` и добавляет полученный результат типа `R` в новый список.
5.  В `main` работа метода продемонстрирована с помощью лямбда-выражений (например, `String::length`).

## Задача 3.2: Фильтр (filter)

### Текст задачи
Разработайте обобщенный метод, который принимает список значений типа `T` и объект с методом `test`. Метод должен вернуть новый список, из которого удалены все значения, не прошедшие проверку `test`.

### Алгоритм решения
1.  Использован стандартный функциональный интерфейс `java.util.function.Predicate<T>`.
2.  Создан статический обобщенный метод `filter` с сигнатурой `<T> List<T> filter(List<T> list, Predicate<T> predicate)`.
3.  Метод создает новый пустой список `ArrayList<T>`.
4.  В цикле для каждого элемента исходного списка вызывается `predicate.test(item)`. Если результат `true`, элемент добавляется в новый список.

## Задача 3.3: Сокращение (reduce)

### Текст задачи
Разработайте обобщенный метод, который принимает список значений типа `T` и способ свести его к одному значению типа `T`. Метод должен гарантированно не возвращать `null` и не выбрасывать ошибок, если список пуст.

### Алгоритм решения
1.  Создан собственный функциональный интерфейс `Reducer<T>` с одним методом `reduce(T accumulator, T item)`.
2.  Создан статический обобщенный метод `reduce` с сигнатурой `<T> T reduce(List<T> list, Reducer<T> reducer, T initialValue)`.
3.  Наличие `initialValue` (начального значения) решает проблему пустого списка: если список пуст, метод просто возвращает это начальное значение.
4.  Внутри метода `result` инициализируется значением `initialValue`, а затем в цикле последовательно "сворачивается" с каждым элементом списка.

## Задача 3.4: Коллекционирование (collect)

### Текст задачи
Разработайте метод, который будет возвращать коллекцию типа `R` со значениями типа `T`. Метод принимает: список исходных значений, способ создания результирующей коллекции и способ передачи значений в нее.

### Алгоритм решения
1.  Для "способа создания" и "способа передачи" были использованы стандартные функциональные интерфейсы: `java.util.function.Supplier<R>` и `java.util.function.BiConsumer<R, T>`.
2.  Создан статический обобщенный метод `collect` с сигнатурой `<T, R> R collect(List<T> list, Supplier<R> supplier, BiConsumer<R, T> accumulator)`.
3.  Механизм работы:
    1.  Сначала с помощью `supplier.get()` создается пустая результирующая коллекция (например, `new ArrayList<>()` или `new HashSet<>()`).
    2.  Затем в цикле каждый элемент `T` из исходного списка добавляется в результирующую коллекцию `R` с помощью `accumulator.accept(result, item)`.
4.  Этот гибкий подход позволяет собирать элементы в любую коллекцию (`List`, `Set`) и даже реализовывать более сложные логики, такие как группировка.