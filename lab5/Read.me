# Абубакиров Артур ФИТ-1 Лабораторная №5

# Задание 1. Шаблоны

## Задача 1.1: Дробь с интерфейсом и кэшированием

### Текст задачи
В класс `Дробь` добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя. Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.

### Алгоритм решения
1.  Создан интерфейс `Fractionable` с методами `doubleValue()`, `setNum()`, `setDen()`.
2.  Создан базовый класс `Fraction`, хранящий числитель и знаменатель.
3.  Создан класс-обертка `CachedFraction`, реализующий интерфейс `Fractionable`.
4.  `CachedFraction` использует **композицию**: он содержит внутри себя экземпляр `Fraction`.
5.  В `CachedFraction` добавлено приватное поле `Double cache`. При первом вызове `doubleValue()` результат вычисляется, сохраняется в `cache` и возвращается. При последующих вызовах возвращается значение из `cache` без повторных вычислений.
6.  Методы `setNum()` и `setDen()` при вызове **инвалидируют кэш** (устанавливают `cache = null`), чтобы при следующем запросе значение было пересчитано заново.

# Задание 2. Структурные шаблоны

## Задача 2.1: Количество мяуканий

### Текст задачи
Воспользоваться классом `Кот` и методом, принимающим всех мяукающих. Необходимо таким образом передать кота в указанный метод, чтобы после окончания его работы узнать, сколько раз мяукал кот. Кота изменять нельзя.

### Алгоритм решения
1.  Для решения задачи применен структурный шаблон **Декоратор**.
2.  Создан общий интерфейс `Meowable` с методом `meow()`.
3.  Базовый класс `Cat` реализует этот интерфейс.
4.  Создан класс `MeowCounterDecorator`, который также реализует `Meowable`. Он "оборачивает" другой объект `Meowable` и хранит внутренний счетчик.
5.  При вызове `meow()` у декоратора он сначала инкрементирует свой счетчик, а затем **делегирует** вызов `meow()` обернутому объекту.
6.  Это позволяет добавить новую функциональность (подсчет), не изменяя исходный класс `Cat`.

# Задание 3. Список

## Задача 3.3: Вставить L2 в L1 с сохранением порядка

### Текст задачи
Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его упорядоченности.

### Алгоритм решения
1.  Задача решена в утилитном методе `ListTasks.mergeSorted`.
2.  Использован простой и эффективный подход: все элементы из списка `L2` добавляются в конец `L1` с помощью `l1.addAll(l2)`.
3.  Затем объединенный список `L1` сортируется с помощью `Collections.sort(l1)`. Этот метод использует эффективный алгоритм сортировки (TimSort), который хорошо работает на частично отсортированных данных.

# Задание 4. Мап

## Задача 4.3: Трое лучших в многоборье

### Текст задачи
На вход программы подаются сведения о результатах соревнований по школьному многоборью. Вывести на экран фамилии и имена трех лучших участников. Если есть участники с одинаковыми баллами, их также следует вывести.

### Алгоритм решения
1.  Данные считываются из текстового файла. Для хранения информации о каждом участнике создан вспомогательный класс `Athlete`.
2.  Все участники считываются в `List<Athlete>`, при этом их баллы по всем видам спорта суммируются.
3.  Список сортируется по убыванию общего количества баллов с помощью `Comparator.comparingInt(Athlete::getTotalScore).reversed()`.
4.  Чтобы корректно обработать ничьи, сначала определяются 3 лучших уникальных результата.
5.  Затем из отсортированного списка выводятся все участники, чей результат не ниже третьего лучшего результата.

# Задание 5. Сет

## Задача 5.7: Сколько разных букв в тексте

### Текст задачи
Файл содержит текст на русском языке. Сколько разных букв встречается в тексте?

### Алгоритм решения
1.  Для решения задачи идеально подходит коллекция `Set`, которая по своей природе хранит только уникальные элементы.
2.  Текст из файла считывается и приводится к нижнему регистру для регистронезависимого подсчета.
3.  Создается `TreeSet<Character>` для хранения букв. `TreeSet` был выбран, чтобы автоматически отсортировать найденные буквы по алфавиту.
4.  Программа итерируется по каждому символу текста. Если символ является буквой (`Character.isLetter()`), он добавляется в `Set`.
5.  Количество разных букв равно финальному размеру `Set` (`uniqueLetters.size()`).

# Задание 6. Очередь

## Задача 6.2: Построить очередь-палиндром

### Текст задачи
По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить очередь из элементов 1, 2, 3, 3, 2, 1).

### Алгоритм решения
1.  Для создания обратной последовательности используется структура данных `Stack` (LIFO - Last-In, First-Out).
2.  Создается результирующая `Queue` (на базе `LinkedList`) и вспомогательный `Stack`.
3.  В цикле проходим по исходному списку: каждый элемент одновременно добавляется в конец очереди (`queue.add()`) и на вершину стека (`stack.push()`).
4.  После первого прохода в очереди находится исходная последовательность.
5.  Во втором цикле, пока стек не пуст, из него извлекаются элементы (`stack.pop()`) и добавляются в конец очереди. Так как элементы из стека извлекаются в обратном порядке, это формирует вторую, "зеркальную" часть последовательности.

# Задание 7. Стрим

## Задача 7.1: Обработка Point'ов

### Текст задачи
Дан набор объектов типа `Point`. Необходимо взять все `Point` в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (`Polyline`).

### Алгоритм решения
1.  Задача решена с помощью **Stream API** в одну цепочку вызовов.
2.  `stream()`: Создает поток из списка точек.
3.  `distinct()`: Удаляет дубликаты. Требует наличия корректно реализованных `equals()` и `hashCode()` в классе `Point`.
4.  `sorted(Comparator.comparingInt(Point::getX))`: Сортирует поток по координате X.
5.  `map(...)`: Преобразует каждый элемент. Если `Y` отрицательный, создается новый `Point` с инвертированным `Y`, иначе точка остается без изменений.
6.  `collect(...)`: Собирает результат. `Collectors.collectingAndThen` используется для того, чтобы сначала собрать обработанные точки в `List`, а затем передать этот список в конструктор `Polyline`.

## Задача 7.2: Обработка файла с именами и номерами

### Текст задачи
Дан текстовый файл со строками `имя:номер`. Необходимо написать стрим, который читает людей из файла, приводит имена к нижнему регистру с заглавной первой буквой, убирает людей без номеров и группирует оставшихся по их номеру.

### Алгоритм решения
1.  Задача решена с помощью **Stream API** и терминальной операции `collect` с коллектором `groupingBy`.
2.  `Files.lines()`: Создает поток строк из файла.
3.  `filter(line -> line.contains(":"))`: Отбрасывает строки, где нет номера.
4.  `map(line -> line.split(":"))`: Разбивает каждую строку на массив из двух элементов: `[имя, номер]`.
5.  `collect(Collectors.groupingBy(...))`: Выполняет группировку.
    *   **Классификатор:** `parts -> Integer.parseInt(parts[1])` — определяет, что ключом в результирующей `Map` будет номер (преобразованный в `Integer`).
    *   **Downstream-коллектор:** `Collectors.mapping(...)` — определяет, как обрабатывать значения, попавшие в одну группу. Он сначала преобразует имя с помощью вспомогательного метода `capitalize`, а затем собирает отформатированные имена в `List`.
6.  В результате получается `Map<Integer, List<String>>`, где ключ — это номер, а значение — список имен, соответствующих этому номеру.
