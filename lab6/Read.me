# Абубакиров Артур ФИТ-1 Лабораторная №6

## Задание 1. Аннотации

### Задачи 1.1 - 1.6: Создание и обработка аннотаций

#### Текст задачи
Разработать аннотации `@Invoke`, `@Default`, `@ToString`, `@Validate`, `@Two`, `@Cache` с заданными характеристиками и реализовать обработчики для них с использованием Reflection API.

#### Алгоритм решения
1.  **Создание аннотаций:** Для каждой задачи был создан свой файл с объявлением аннотации (`@interface`).
    *   `@Retention(RetentionPolicy.RUNTIME)`: Установлено для всех аннотаций, чтобы они были доступны во время выполнения программы через рефлексию.
    *   `@Target(...)`: Указаны цели, к которым можно применять аннотацию (методы, типы, поля).
    *   **Свойства аннотаций:** Объявлены методы для свойств (`value()`, `first()`, `second()`, и т.д.) с указанием типов и, при необходимости, значений по умолчанию (`default ...`).

2.  **Создание обработчиков:**
    *   **`AnnotationProcessor`:** Создан универсальный обработчик, который принимает `Object` и с помощью рефлексии (`obj.getClass()`, `.getAnnotation()`, `.getDeclaredMethods()`, etc.) анализирует его на наличие аннотаций. Для каждой найденной аннотации он выполняет требуемое действие: вызывает метод, считывает и выводит свойства.
    *   **`ToStringProcessor`:** Создан отдельный, более сложный обработчик для `@ToString`. Он анализирует поля объекта, проверяет наличие и значение аннотации `@ToString` на них и формирует итоговую строку, пропуская поля, помеченные как `Mode.NO`. Для доступа к приватным полям используется `field.setAccessible(true)`.

3.  **Демонстрация:** Созданы классы-модели (`User`, `MyService`), которые используют все разработанные аннотации. В `main` создаются экземпляры этих классов и передаются в обработчики для демонстрации их работы.

## Задание 2. Тестирование

### Задача 2.1: Тест для `@ToString`

#### Текст задачи
Напишите тест, используя фреймворк JUnit, к методу, формирующему строковое представление объекта, основанное на аннотации `@ToString`. Проверить, что в результирующей строке отображаются только те поля, которые не имеют аннотацию `@ToString(Mode.NO)`.

#### Алгоритм решения
1.  Создан тестовый класс `UserTest` в директории `src/test/java`.
2.  Для подключения JUnit 5 в проект был добавлен `pom.xml` с соответствующими зависимостями (`junit-jupiter-api`, `junit-jupiter-engine`).
3.  Написан тестовый метод `testToStringAnnotation()`, помеченный аннотацией `@Test` из JUnit 5.
4.  **Arrange:** Создается тестовый экземпляр класса `User`, у которого одно из полей (`password`) помечено как `@ToString(Mode.NO)`.
5.  **Act:** Вызывается `ToStringProcessor.process()` для этого объекта.
6.  **Assert:** С помощью методов из `org.junit.jupiter.api.Assertions` (`assertTrue`, `assertFalse`, `assertEquals`) выполняются проверки:
    *   Что строка содержит имена полей, которые должны быть включены.
    *   Что строка **не содержит** имя поля, помеченного `Mode.NO`.
    *   Что итоговая строка в точности соответствует ожидаемому формату.

### Задача 2.7: Совместный тест для `@Cache` и `@Invoke`

#### Текст задачи
Создайте тест, используя JUnit, проверяющий совместную работу аннотаций `@Cache` и `@Invoke` на одном классе.

#### Алгоритм решения
1.  Создан тестовый класс `MyServiceTest` в директории `src/test/java`.
2.  Метод `setUp()`, помеченный аннотацией `@BeforeEach`, создает новый экземпляр `MyService` перед каждым тестом, обеспечивая их независимость.
3.  **Arrange:** В тестовом методе `testCacheAndInvokeTogether()` с помощью рефлексии (`myService.getClass().getAnnotation(Cache.class)`) получается экземпляр аннотации `@Cache`, и проверяется, что она существует и содержит корректные данные (`assertNotNull`, `assertArrayEquals`).
4.  **Act:** С помощью рефлексии находится метод, помеченный `@Invoke`, и вызывается (`method.invoke(myService)`).
5.  **Assert:** Выполняется ряд проверок:
    *   Что метод с `@Invoke` действительно был найден и вызван.
    *   Что побочный эффект от вызова метода произошел (внутренний флаг `invoked` стал `true`).
    *   Что логика, связанная с `@Cache` (имитация кэширования), которая находится внутри метода `@Invoke`, также выполнилась корректно (внутренняя `Map` заполнилась ожидаемыми данными).